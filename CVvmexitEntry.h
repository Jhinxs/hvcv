#pragma once
#include "common.h"

VOID VmHostEntry(PGUEST_REGS g_GUEST_REGS);
BOOLEAN VmhostEntrydbg(PGUEST_REGS g_GUEST_REGS);
#define MAKEQWORD(low, hi) ((((ULONGLONG)low) & 0xFFFFFFFF) | ((((ULONGLONG)hi) & 0xFFFFFFFF) << 32))


typedef enum
{
	EXIT_REASON_EXCEPTION_NMI = 0,
	EXIT_REASON_EXTERNAL_INTERRUPT = 1,
	EXIT_REASON_TRIPLE_FAULT = 2,
	EXIT_REASON_INIT = 3,
	EXIT_REASON_SIPI = 4,
	EXIT_REASON_IO_SMI = 5,
	EXIT_REASON_OTHER_SMI = 6,
	EXIT_REASON_PENDING_VIRT_INTR = 7,
	EXIT_REASON_PENDING_VIRT_NMI = 8,
	EXIT_REASON_TASK_SWITCH = 9,
	EXIT_REASON_CPUID = 10,
	EXIT_REASON_HLT = 12,
	EXIT_REASON_INVD = 13,
	EXIT_REASON_INVLPG = 14,
	EXIT_REASON_RDPMC = 15,
	EXIT_REASON_RDTSC = 16,
	EXIT_REASON_RSM = 17,
	EXIT_REASON_VMCALL = 18,
	EXIT_REASON_VMCLEAR = 19,
	EXIT_REASON_VMLAUNCH = 20,
	EXIT_REASON_VMPTRLD = 21,
	EXIT_REASON_VMPTRST = 22,
	EXIT_REASON_VMREAD = 23,
	EXIT_REASON_VMRESUME = 24,
	EXIT_REASON_VMWRITE = 25,
	EXIT_REASON_VMXOFF = 26,
	EXIT_REASON_VMXON = 27,
	EXIT_REASON_CR_ACCESS = 28,
	EXIT_REASON_DR_ACCESS = 29,
	EXIT_REASON_IO_INSTRUCTION = 30,
	EXIT_REASON_MSR_READ = 31,
	EXIT_REASON_MSR_WRITE = 32,
	EXIT_REASON_INVALID_GUEST_STATE = 33,
	EXIT_REASON_MSR_LOADING = 34,
	EXIT_REASON_MWAIT_INSTRUCTION = 36,
	EXIT_REASON_MTF_TRAP_FLAG = 37,
	EXIT_REASON_MONITOR_INSTRUCTION = 39,
	EXIT_REASON_PAUSE_INSTRUCTION = 40,
	EXIT_REASON_MACHINE_CHECK = 41,
	EXIT_REASON_TPR_BELOW_THRESHOLD = 43,
	EXIT_REASON_APIC_ACCESS = 44,
	EXIT_REASON_EPT_VIOLATION = 48,
	EXIT_REASON_EPT_MISCONFIG = 49,
	EXIT_REASON_RDTSCP = 51,
	EXIT_REASON_VMX_Preemption = 52,
	EXIT_REASON_INVVPID = 53,
	EXIT_REASON_WBINVD = 54,
	EXIT_REASON_XSETBV = 55,
	EXIT_REASON_APIC_WRITE = 56,
	EXIT_REASON_RDRAND = 57

} vm_exit_reason;

typedef union _ACCESS_CR_QUALIFICATION 
{
	ULONG64 all;
	struct 
	{
		ULONG ControlRegister : 4;
		ULONG AccessType : 2;
		ULONG LMSWOperandType : 1;
		ULONG Reserved1 : 1;
		ULONG GPRegister : 4;                    //访问CR寄存器所使用的通用寄存器
		ULONG Reserved2 : 4;
		ULONG LMSWSourceData : 16;
		ULONG Reserved3;
	}Bits;
}ACCESS_CR_QUALIFICATION,*PACCESS_CR_QUALIFICATION;


typedef enum _EXCEPTION_VECTORS
{
	EXCEPTION_VECTOR_DIVIDE_ERROR,
	EXCEPTION_VECTOR_DEBUG_BREAKPOINT,
	EXCEPTION_VECTOR_NMI,
	EXCEPTION_VECTOR_BREAKPOINT,
	EXCEPTION_VECTOR_OVERFLOW,
	EXCEPTION_VECTOR_BOUND_RANGE_EXCEEDED,
	EXCEPTION_VECTOR_UNDEFINED_OPCODE,
	EXCEPTION_VECTOR_NO_MATH_COPROCESSOR,
	EXCEPTION_VECTOR_DOUBLE_FAULT,
	EXCEPTION_VECTOR_RESERVED0,
	EXCEPTION_VECTOR_INVALID_TASK_SEGMENT_SELECTOR,
	EXCEPTION_VECTOR_SEGMENT_NOT_PRESENT,
	EXCEPTION_VECTOR_STACK_SEGMENT_FAULT,
	EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT,
	EXCEPTION_VECTOR_PAGE_FAULT,
	EXCEPTION_VECTOR_RESERVED1,
	EXCEPTION_VECTOR_MATH_FAULT,
	EXCEPTION_VECTOR_ALIGNMENT_CHECK,
	EXCEPTION_VECTOR_MACHINE_CHECK,
	EXCEPTION_VECTOR_SIMD_FLOATING_POINT_NUMERIC_ERROR,
	EXCEPTION_VECTOR_VIRTUAL_EXCEPTION,
	EXCEPTION_VECTOR_RESERVED2,
	EXCEPTION_VECTOR_RESERVED3,
	EXCEPTION_VECTOR_RESERVED4,
	EXCEPTION_VECTOR_RESERVED5,
	EXCEPTION_VECTOR_RESERVED6,
	EXCEPTION_VECTOR_RESERVED7,
	EXCEPTION_VECTOR_RESERVED8,
	EXCEPTION_VECTOR_RESERVED9,
	EXCEPTION_VECTOR_RESERVED10,
	EXCEPTION_VECTOR_RESERVED11,
	EXCEPTION_VECTOR_RESERVED12
}EXCEPTION_VECTORS;

typedef union _VMEXIT_INTERRUPT_INFO {
	struct {
		UINT32 Vector : 8;
		UINT32 InterruptionType : 3;
		UINT32 ErrorCodeValid : 1;
		UINT32 NmiUnblocking : 1;
		UINT32 Reserved : 18;
		UINT32 Valid : 1;
	} Bits;
	UINT32 all;
}VMEXIT_INTERRUPT_INFO, *PVMEXIT_INTERRUPT_INFO;


typedef union _INTERRUPT_INFO {
	struct {
		UINT32 Vector : 8;
		UINT32 InterruptType : 3;
		UINT32 DeliverCode : 1;  
		UINT32 Reserved : 19;
		UINT32 Valid : 1;         
	}Bits;
	UINT32 all;
} INTERRUPT_INFO, * PINTERRUPT_INFO;

typedef struct _EVENT_INFORMATION
{
	INTERRUPT_INFO InterruptInfo;
	UINT32 InstructionLength;
	UINT64 ErrorCode;
}EVENT_INFORMATION, * PEVENT_INFORMATION;

typedef enum _INTERRUPT_TYPE
{
	INTERRUPT_TYPE_EXTERNAL_INTERRUPT = 0,
	INTERRUPT_TYPE_RESERVED = 1,
	INTERRUPT_TYPE_NMI = 2,
	INTERRUPT_TYPE_HARDWARE_EXCEPTION = 3,
	INTERRUPT_TYPE_SOFTWARE_INTERRUPT = 4,
	INTERRUPT_TYPE_PRIVILEGED_SOFTWARE_INTERRUPT = 5,
	INTERRUPT_TYPE_SOFTWARE_EXCEPTION = 6,
	INTERRUPT_TYPE_OTHER_EVENT = 7
}INTERRUPT_TYPE;

VOID CVVmxOff();